#include "InterfaceCUDA.h"

/*! \file Kernels.cu
    \brief Definitions of CUDA kernels for TiEMPO2.

    author: Arend Moerman
*/

// PHYSICAL CONSTANTS
__constant__ float cPI;                     // Pi
__constant__ float cCL;                     // speed of light
__constant__ float cHP;                     // Planck constant
__constant__ float cKB;                     // Boltzmann constant

// OBSERVATION-INSTRUMENT PARAMETERS
__constant__ float const_effs[CEFFSSIZE];   // Contains constant efficiencies:chain, gnd, mir, pb 
__constant__ float cdt;                     // Timestep
__constant__ float cfreq_chop;              // Chopping frequency
__constant__ float cfreq_nod;               // Nodding frequency
__constant__ float cfreq_sample;            // Sampling frequency of readout
__constant__ float cdAz_chop;               // Chopping throw
__constant__ float cdelta;                  // Bandgap energy of MKID
__constant__ int cnt;                       // Number of time evals
__constant__ int cnf_filt;                  // Number of filter freqs
__constant__ int cchop_mode;                // What chopping scheme to use

// ATMOSPHERE PARAMETERS
__constant__ float ch_column;               // Column height
__constant__ float cv_wind;                 // Windspeed

__constant__ float cx0_atm;                 /**< Start x-value of atmosphere screen.*/
__constant__ float cdx_atm;                 /**< Stepsize of x-array in atmosphere screen.*/
__constant__ int cnx_atm;                   /**< Number of x points in screen.*/

__constant__ float cy0_atm;                 /**< Start y-value of atmosphere screen.*/
__constant__ float cdy_atm;                 /**< Stepsize of y-array in atmosphere screen.*/
__constant__ int cny_atm;                   /**< Number of y points in screen.*/

__constant__ float cf0_atm;                 /**< Start frequency for ATM-model.*/
__constant__ float cdf_atm;                 /**< Stepsize of frequencies in ATM-model.*/
__constant__ int cnf_atm;                   /**< Number of frequencies in ATM-model.*/

__constant__ float cPWV0_atm;               /**< Start PWV value for ATM-model.*/
__constant__ float cdPWV_atm;               /**< Stepsize for PWV in ATM-model.*/
__constant__ int cnPWV_atm;                 /**< Number of PWV values in ATM-model.*/

// SOURCE PARAMETERS
__constant__ float cAz0_src;                 /**< Start azimuth of source.*/
__constant__ float cdAz_src;                 /**< Stepsize of azimuth.*/
__constant__ int cnAz_src;                   /**< Number of elements in source azimuth.*/

__constant__ float cEl0_src;                 /**< Start elevation of source.*/
__constant__ float cdEl_src;                 /**< Stepsize of elevation.*/
__constant__ int cnEl_src;                   /**< Number of elements in source elevation.*/

__constant__ float cf0_src;                  /**< Start frequency of source.*/
__constant__ float cdf_src;                 /**< Stepsize of array.*/
__constant__ int cnf_src;                   /**< Number of elements in source frequencies.*/

// SCAN PARAMETERS
__constant__ int cscantype;
__constant__ float cAx;
__constant__ float cAxmin;
__constant__ float cAy;
__constant__ float cAymin;
__constant__ float cwx;
__constant__ float cwxmin;
__constant__ float cwy;
__constant__ float cwymin;
__constant__ float cphix;
__constant__ float cphiy;

// TEXTURE MEMORY
texture<float, cudaTextureType1D, cudaReadModeElementType> tex_filterbank;
texture<float, cudaTextureType1D, cudaReadModeElementType> tex_eta_ap_ON;
texture<float, cudaTextureType1D, cudaReadModeElementType> tex_eta_ap_OFF;

#define gpuErrchk(ans) { gpuAssert((ans), __FILE__, __LINE__); }

/**
  Check CUDA API error status of call.
 
  Wrapper for finding errors in CUDA API calls.
 
  @param code The errorcode returned from failed API call.
  @param file The file in which failure occured.
  @param line The line in file in which error occured.
  @param abort Exit code upon error.
 */
inline void gpuAssert(cudaError_t code, const char *file, int line, bool abort = true)
{
   if (code != cudaSuccess)
   {
      fprintf(stderr,"GPUassert: %s %s %d\n", cudaGetErrorString(code), file, line);
      if (abort) exit(code);
   }
}

/**
  Struct for passing an array to kernel.

  Eliminates the need to pass long arrays that can be described by start, step and number.
 */
typedef struct
{
    float start, step;      /**< Start of array and stepsize.*/
    int number;             /**< Number of elements in array.*/
} arr_data;

/**
  Calculate Planckian distribution.

  Used for calculating blackbody intensities of atmosphere, ground and telescope.

  @param T Temperature of blackbody, in Kelvin.
  @param nu Frequency at which to evaluate blackbody, in Hertz.

  @returns Blackbody intensity.
 */
__host__ float getPlanck(float T, float nu)
{
    float CL = 2.9979246e8; // m s^-1
    float HP = 6.62607015e-34;
    float KB = 1.380649e-23;
    
    float prefac = 2 * HP * nu*nu*nu / (CL*CL);
    float dist = 1 / (exp(HP*nu / (KB*T)) - 1);
    
    return prefac * dist;
}

/**
  Calculate sign of number.

  Used in determining chop-nod state.

  @param val Value of number.
 */
__device__ __inline__ void sgn(float val, int &out) {
    out = (float(0) < val) - (val < float(0));
}

/**
  Convert angle in arcseconds to radian.

  @param ang Angle in arcseconds.
 */
__device__ __inline__ float as2rad(float ang) {
    return ang / 3600 / 180 * cPI;
}

/**
  Calculate new Azimuth-Elevation co-ordinate, accoding to chop position.

  This function just "scans" a single point, so seems sort of pointless. 
  Still implemented for completeness.

  @param center Az-El co-ordinate of point to observe, w.r.t. source Az-El.
  @param out Container for storing output Az-El co-ordinate.
  @param chop Whether chopper is in A (false) or B (true).
  @param sep Angular throw between chop A and B, in degrees.
 */
__device__ __inline__ void scanPoint(AzEl* center, AzEl* out, bool chop, float sep = 0.) {
    float offset = 0.;
    
    if (chop) {
        offset = sep;
    }    
    out->Az = center->Az + offset;
    out->El = center->El;
}

__device__ __inline__ void scanDaisy(AzEl* center, AzEl* out, float t, bool chop, float sep = 0.) {
    float offset = 0.;
    
    if (chop) {
        offset = sep;
    }    
    
    out->Az = center->Az + offset + cAx*sinf(cwx*t)*cosf(cwx*t + as2rad(cphix)) + cAxmin*sinf(cwxmin*t)*cosf(cwxmin*t + as2rad(cphix));
    out->El = center->El + cAy*sinf(cwy*t)*sinf(cwy*t + as2rad(cphiy)) + cAymin*sinf(cwymin*t)*sinf(cwymin*t + as2rad(cphiy)) - cAy;
}

/**
  Convert an Az-El co-ordinate to a projected x-y co-ordinate on the atmosphere.

  @param angles Az-El co-ordinate to convert.
  @param out Container for storing the calculated x-y point.
 */
__device__ __inline__ void convertAnglesToSpatialAtm(AzEl* angles, xy_atm* out) {
    
    float coord = tanf(cPI * angles->Az / 180.) * ch_column;
    
    out->xAz = coord;
    coord = tanf(cPI * angles->El / 180.) * ch_column;
    out->yEl = coord;
}

__device__ __inline__ void getABBA_posflag(float &t_start, AzEl *center, AzEl *pointing, int &flagout) {
    int n_chop;
    int n_nod;
    int position;

    bool chop_flag;

    float is_in_lower_half;
    int nod_flag;

    n_chop = floorf(t_start * cfreq_chop);
    n_nod = floorf(t_start * cfreq_nod);
    
    chop_flag = (n_chop % 2 != 0); // If even (false), ON. Odd (true), OFF.
    nod_flag = -1 + 2 * (n_nod % 2 != 0); // If even (false), AB. Odd (true), BA.
    
    is_in_lower_half = (t_start - n_nod / cfreq_nod) - (1 / cfreq_nod / 2);
    sgn(is_in_lower_half, position);
    position *= nod_flag;
    
    scanPoint(center, pointing, chop_flag, position * cdAz_chop);
    flagout = chop_flag * position + (1 - chop_flag) * (1 - position);
}

__device__ __inline__ void getONOFF_posflag(float &t_start, AzEl *center, AzEl *pointing, int &flagout) {
    int n_chop;
    bool chop_flag;

    n_chop = floorf(t_start * cfreq_chop);
    
    chop_flag = (n_chop % 2 != 0); // If even (false), ON. Odd (true), OFF.
    if(cscantype == 0) {scanPoint(center, pointing, chop_flag, cdAz_chop);}
    else if(cscantype == 1) {scanDaisy(center, pointing, t_start, chop_flag, cdAz_chop);}
    flagout = chop_flag;
}

__device__ __inline__ void getnochop_posflag(float &t_start, AzEl *center, AzEl *pointing, int &flagout) {
    if(cscantype == 0) {scanPoint(center, pointing, 0, cdAz_chop);}
    else if(cscantype == 1) {scanDaisy(center, pointing, t_start, 0, cdAz_chop);}
    flagout = 0;
}

/**
  Initialize CUDA.
 
  Instantiate program and populate constant memory.
 
  @param instrument CuInstrument object containing instrument to be simulated.
  @param telescope CuTelescope object containing telescope to be simulated.
  @param simparams CuSimParams object containing simulation parameters.
  @param source CuSource object containing source definitions.
  @param atmosphere CuAtmosphere object containing atmosphere parameters.
  @param nThreads Number of CUDA threads per block.
 
  @return BT Array of two dim3 objects, containing number of blocks per grid and number of threads per block.
 */
__host__ void initCUDA(CuInstrument *instrument, CuTelescope *telescope, CuSimParams *simparams, CuSource *source, CuAtmosphere *atmosphere) {
    //int nBlocks = ceilf((float)simparams->nTimes / nThreads);

    // Calculate nr of blocks per grid and nr of threads per block
    //dim3 nrb(nBlocks); dim3 nrt(nThreads);


    float PI = 3.1415926; /* pi */
    float CL = 2.9979246e8; // m s^-1
    float HP = 6.62607015e-34;
    float KB = 1.380649e-23;

    // Pack constant array
    float _con[CEFFSSIZE] = {instrument->eta_inst * instrument->eta_misc * telescope->eta_fwd * telescope->eta_mir * 0.5,
        instrument->eta_inst * instrument->eta_misc * (1 - telescope->eta_fwd) * telescope->eta_mir * 0.5,
        instrument->eta_inst * instrument->eta_misc * (1 - telescope->eta_mir) * 0.5, 
        instrument->eta_pb};

    float dt = 1. / instrument->freq_sample;
    
    // PHYSICAL CONSTANTS
    gpuErrchk( cudaMemcpyToSymbol(cPI, &PI, sizeof(float)) );
    gpuErrchk( cudaMemcpyToSymbol(cCL, &CL, sizeof(float)) );
    gpuErrchk( cudaMemcpyToSymbol(cHP, &HP, sizeof(float)) );
    gpuErrchk( cudaMemcpyToSymbol(cKB, &KB, sizeof(float)) );
     
    // OBSERVATION-INSTRUMENT PARAMETERS
    gpuErrchk( cudaMemcpyToSymbol(const_effs, &_con, CEFFSSIZE * sizeof(float)) );
    gpuErrchk( cudaMemcpyToSymbol(cdt, &dt, sizeof(float)) );
    gpuErrchk( cudaMemcpyToSymbol(cfreq_chop, &(telescope->freq_chop), sizeof(float)) );
    gpuErrchk( cudaMemcpyToSymbol(cfreq_nod, &(telescope->freq_nod), sizeof(float)) );
    gpuErrchk( cudaMemcpyToSymbol(cfreq_sample, &(instrument->freq_sample), sizeof(float)) );
    gpuErrchk( cudaMemcpyToSymbol(cdAz_chop, &(telescope->dAz_chop), sizeof(float)) );
    gpuErrchk( cudaMemcpyToSymbol(cdelta, &(instrument->delta), sizeof(float)) );
    gpuErrchk( cudaMemcpyToSymbol(cnt, &(simparams->nTimes), sizeof(int)) );
    gpuErrchk( cudaMemcpyToSymbol(cnf_filt, &(instrument->nfreqs_filt), sizeof(int)) );
    gpuErrchk( cudaMemcpyToSymbol(cchop_mode, &(telescope->chop_mode), sizeof(int)) );
    
    // ATMOSPHERE PARAMETERS
    gpuErrchk( cudaMemcpyToSymbol(ch_column, &(atmosphere->h_column), sizeof(float)) );
    gpuErrchk( cudaMemcpyToSymbol(cv_wind, &(atmosphere->v_wind), sizeof(float)) );
    
    gpuErrchk( cudaMemcpyToSymbol(cx0_atm, &(atmosphere->x0), sizeof(float)) );
    gpuErrchk( cudaMemcpyToSymbol(cdx_atm, &(atmosphere->dx), sizeof(float)) );
    gpuErrchk( cudaMemcpyToSymbol(cnx_atm, &(atmosphere->nx), sizeof(int)) );

    gpuErrchk( cudaMemcpyToSymbol(cy0_atm, &(atmosphere->y0), sizeof(float)) );
    gpuErrchk( cudaMemcpyToSymbol(cdy_atm, &(atmosphere->dy), sizeof(float)) );
    gpuErrchk( cudaMemcpyToSymbol(cny_atm, &(atmosphere->ny), sizeof(int)) );
    
    gpuErrchk( cudaMemcpyToSymbol(cf0_atm, &(atmosphere->f0), sizeof(float)) );
    gpuErrchk( cudaMemcpyToSymbol(cdf_atm, &(atmosphere->df), sizeof(float)) );
    gpuErrchk( cudaMemcpyToSymbol(cnf_atm, &(atmosphere->nf), sizeof(int)) );
    
    gpuErrchk( cudaMemcpyToSymbol(cPWV0_atm, &(atmosphere->PWV0), sizeof(float)) );
    gpuErrchk( cudaMemcpyToSymbol(cdPWV_atm, &(atmosphere->dPWV), sizeof(float)) );
    gpuErrchk( cudaMemcpyToSymbol(cnPWV_atm, &(atmosphere->nPWV), sizeof(int)) );

    // SOURCE PARAMETERS
    gpuErrchk( cudaMemcpyToSymbol(cAz0_src, &(source->Az0), sizeof(float)) );
    gpuErrchk( cudaMemcpyToSymbol(cdAz_src, &(source->dAz), sizeof(float)) );
    gpuErrchk( cudaMemcpyToSymbol(cnAz_src, &(source->nAz), sizeof(int)) );
    
    gpuErrchk( cudaMemcpyToSymbol(cEl0_src, &(source->El0), sizeof(float)) );
    gpuErrchk( cudaMemcpyToSymbol(cdEl_src, &(source->dEl), sizeof(float)) );
    gpuErrchk( cudaMemcpyToSymbol(cnEl_src, &(source->nEl), sizeof(int)) );
    
    gpuErrchk( cudaMemcpyToSymbol(cf0_src, &(source->f0), sizeof(float)) );
    gpuErrchk( cudaMemcpyToSymbol(cdf_src, &(source->df), sizeof(float)) );
    gpuErrchk( cudaMemcpyToSymbol(cnf_src, &(source->nf), sizeof(int)) );

    // SCAN PARAMETERS
    gpuErrchk( cudaMemcpyToSymbol(cscantype, &(telescope->scantype), sizeof(int)) );
    gpuErrchk( cudaMemcpyToSymbol(cAx, &(telescope->Ax), sizeof(float)) );
    gpuErrchk( cudaMemcpyToSymbol(cAxmin, &(telescope->Axmin), sizeof(float)) );
    gpuErrchk( cudaMemcpyToSymbol(cAy, &(telescope->Ay), sizeof(float)) );
    gpuErrchk( cudaMemcpyToSymbol(cAymin, &(telescope->Aymin), sizeof(float)) );
    gpuErrchk( cudaMemcpyToSymbol(cwx, &(telescope->wx), sizeof(float)) );
    gpuErrchk( cudaMemcpyToSymbol(cwxmin, &(telescope->wxmin), sizeof(float)) );
    gpuErrchk( cudaMemcpyToSymbol(cwy, &(telescope->wy), sizeof(float)) );
    gpuErrchk( cudaMemcpyToSymbol(cwymin, &(telescope->wymin), sizeof(float)) );
    gpuErrchk( cudaMemcpyToSymbol(cphix, &(telescope->phix), sizeof(float)) );
    gpuErrchk( cudaMemcpyToSymbol(cphiy, &(telescope->phiy), sizeof(float)) );
}

/**
  Obtain timestream for chopping states, PWV from atmosphere, and rng for Gaussian draw.
  Each timestep gets a new seed for the Gaussian, just to randomise it even harder.
  
  @param state Array of curand states. Should be initialised and sized to total number of threads in grid.
  @param seed Integer describing the seed of the generator.
 */
__global__ void get_chop_pwv_rng(float *center, float *PWV_screen, float *PWV_out, 
                                 int *flag_out, float *az_out, float *el_out,
                                 int *idx_Az, int *idx_El,
                                 curandState *state, unsigned long long int seed = 0) {
    if (!seed) {
        seed = clock64();
    }

    for (int idx = blockIdx.x * blockDim.x + threadIdx.x; 
        idx < cnt; 
        idx += blockDim.x * gridDim.x) {

        AzEl pointing;
        AzEl center_p;
        
        center_p.Az = center[0];
        center_p.El = center[1];

        xy_atm point_atm;

        int flag;

        float Az_src_max = cAz0_src + cdAz_src * (cnAz_src - 1);
        float El_src_max = cEl0_src + cdEl_src * (cnEl_src - 1);

        float t_start = idx * cdt;
        
        if(cchop_mode == 0) {getnochop_posflag(t_start, &center_p, &pointing, flag);}
        else if(cchop_mode == 1) {getONOFF_posflag(t_start, &center_p, &pointing, flag);}
        else if(cchop_mode == 2) {getABBA_posflag(t_start, &center_p, &pointing, flag);}

        convertAnglesToSpatialAtm(&pointing, &point_atm);

        // Add wind to this - currently only along x-axis and pretty manual
        point_atm.xAz = point_atm.xAz + cv_wind * t_start;
    
        __syncthreads();
        idx_Az[idx] = floorf((pointing.Az - cAz0_src) / cdAz_src);
        idx_El[idx] = floorf((pointing.El - cEl0_src) / cdEl_src);

        curand_init(seed, idx, 0, &state[idx]);
        az_out[idx] = pointing.Az;
        el_out[idx] = pointing.El;
        flag_out[idx] = flag;
        
        // Interpolate on PWV_Gauss
        PWV_out[idx] = interpValue(point_atm.xAz, point_atm.yEl, 
                cx0_atm, cy0_atm, cnx_atm, cny_atm, cdx_atm, cdy_atm, PWV_screen, 0);
    }
}

/**
  Main simulation kernel. This is where the magic happens.

  @param I_atm Array containing blackbody intensity of atmosphere, in SI units.
  @param I_gnd Array containing blackbody intensity of ground, in SI units.
  @param I_tel Array containing blackbody intensity of telescope, in SI units.
  @param I_CMB Array containing blackbody intensity of CMB, in SI units.
  @param sigout Array for storing output power, for each channel, for each time, in SI units.
  @param flagout Array for storing wether beam is in chop A or B, in nod AB or BA.
  @param eta_ap Array containing aperture efficiencies, for each bin frequency.
  @param PWV_screen Array containing PWV value of atmosphere, over the range described by x_atm and y_atm, in millimeters.
  @param eta_atm Array with transmission parameters as fuiunction of freqs_atm and PWV_atm.
  @param filterbank Array containing filterbank of instrument.
  @param source Array containing source intensity, as function of azsrc, elsrc and freqs_src, in SI units.
  @param state Array with states for drawing random Gaussian values for noise calculations.
 */
__global__ void runSimulation(float *I_atm, float *I_gnd, float *I_tel, float *I_CMB,
        float *sigout, float *azout, float *elout, int *flagout,
        int *idx_Az, int *idx_El,
        float *PWV_trace, float *eta_atm, float *source, curandState *state) {
    
    for (int idx = blockIdx.x * blockDim.x + threadIdx.x; 
        idx < cnt; 
        idx += blockDim.x * gridDim.x) {
        
        //__shared__ 

        float t_start; // Time from start of observation.
        float eta_atm_interp; // Interpolated eta_atm, over frequency and PWV
        float freq; // Bin frequency
        float I_nu; // Specific intensity of source.
        float sigma_k; // Noise per channel.
        float eta_kj; // Filter efficiency for bin j, at channel k

        int _i_src = idx_Az[idx];
        int _j_src = idx_El[idx];

        float sqrt_samp = sqrtf(0.5 * cfreq_sample); // Constant term needed for noise calculation
            
        AzEl pointing;
        curandState localState = state[idx];

        pointing.Az = azout[idx];
        pointing.El = elout[idx];
        float PWV_tr = PWV_trace[idx];
        int flag = flagout[idx];

        float Az_src_max = cAz0_src + cdAz_src * (cnAz_src - 1);
        float El_src_max = cEl0_src + cdEl_src * (cnEl_src - 1);
        
        AzEl center;

        center.Az = 0;
        center.El = 0;

        bool offsource = ((pointing.Az < cAz0_src) or (pointing.Az > Az_src_max)) or 
                         ((pointing.El < cEl0_src) or (pointing.El > El_src_max));

        float* PSD_nu = new float[cnf_src];
        double eta_ap;

        int start_slice = _i_src * cnf_src + _j_src * cnf_src * cAz0_src;
        
        float t_src = (pointing.Az - (cAz0_src + cdAz_src*_i_src)) / cdAz_src;
        float u_src = (pointing.El - (cEl0_src + cdEl_src*_j_src)) / cdEl_src;

        for(int j=0; j<cnf_src; j++)
        {   
            freq = cf0_src + cdf_src * j;
            eta_atm_interp = interpValue(PWV_tr, freq, 
                    cPWV0_atm, cf0_atm, cnPWV_atm, cnf_atm, cdPWV_atm, cdf_atm, eta_atm, 0);

            if(offsource) {I_nu = I_CMB[j];}
            
            else {
                I_nu = (1-t_src)*(1-u_src) * source[start_slice + j];
                I_nu += t_src*(1-u_src) * source[start_slice + cnf_src + j];
                I_nu += t_src*u_src * source[start_slice + cnf_src*cnAz_src + j];
                I_nu += (1-t_src)*u_src * source[start_slice + cnf_src * (1 + cnAz_src) + j];
            }

            if(flag == 0 or flag == -1) {
                eta_ap = tex1Dfetch(tex_eta_ap_ON, j); 
            }

            else {
                eta_ap = tex1Dfetch(tex_eta_ap_OFF, j);
            }

            PSD_nu[j] = eta_ap * eta_atm_interp * const_effs[0] * I_nu;
                //+ ( const_effs[0] * (1 - eta_atm_interp) * I_atm[j] 
                //+ const_effs[1] * I_gnd[j] 
                //+ const_effs[2] * I_tel[j]) 
                //* cCL*cCL / (freq*freq);
            PSD_nu[j] = I_nu;
        }
        
        // In this loop, calculate P_k, NEP_k and noise
        curand_normal(&localState);
        state[idx] = localState;
       
        
        __syncthreads(); 
        for(int k=0; k<cnf_filt; k++) {
            float P_k = 0.; // Initialise each channel to zero, for each timestep
            float NEP_accum = 0.;

            // Can loop over bins again, cheap operations this time
            for(int j=0; j<cnf_src; j++) {   
                freq = cf0_src + cdf_src * j;
                eta_kj = tex1Dfetch( tex_filterbank, k*cnf_src + j);
                
                NEP_accum += PSD_nu[j] * eta_kj * (cHP * freq + PSD_nu[j] * eta_kj + 2 * cdelta / const_effs[3]);
                P_k += PSD_nu[j] * eta_kj;
            }

            sigma_k = sqrt(2 * NEP_accum * cdf_src) * sqrt_samp;
            P_k *= cdf_src;

            //P_k += sigma_k * curand_normal(&localState);
           
            // STORAGE: Add signal to signal array in output
            __syncthreads(); 
            sigout[k * cnt + idx] = P_k; 
        }
        delete[] PSD_nu;
    }
}

/**
  Run a TiEMPO2 simulation using CUDA.
 
  This function is exposed to the ctypes interface and can be called from Python..
 
  @param instrument CuInstrument object containing instrument to be simulated.
  @param telescope CuTelescope object containing telescope to be simulated.
  @param atmosphere CuAtmosphere object containing atmosphere parameters.
  @param source CuSource object containing source definitions.
  @param simparams CuSimParams object containing simulation parameters.
  @param output CuOutput object for storing simulation output.
 */
void runTiEMPO2_CUDA(CuInstrument *instrument, CuTelescope *telescope, CuAtmosphere *atmosphere, CuSource *source, 
        CuSimParams *simparams, CuOutput *output) {

    Timer timer;
    int numSMs;
    cudaDeviceGetAttribute(&numSMs, cudaDevAttrMultiProcessorCount, 0);
    // Set total heap reservation to 128 mb
    gpuErrchk( cudaDeviceSetLimit(cudaLimitMallocHeapSize, 128*1024*1024) );

    int nThreads1D = 256;
    int nBlocks1D = ceilf((float)simparams->nTimes / nThreads1D / numSMs);
    printf("%d %d\n", numSMs, nBlocks1D); 

    dim3 blockSize1D = nThreads1D;
    dim3 gridSize1D = nBlocks1D*numSMs;

    timer.start();
    
    initCUDA(instrument, telescope, simparams, source, atmosphere);
    
    // Allocate output arrays
    float *sigout;
    gpuErrchk( cudaMalloc((void**)&sigout, (instrument->nfreqs_filt * simparams->nTimes) * sizeof(float)) );
    float *azout, *elout;
    gpuErrchk( cudaMalloc((void**)&azout, simparams->nTimes * sizeof(float)) );
    gpuErrchk( cudaMalloc((void**)&elout, simparams->nTimes * sizeof(float)) );
    
    int *flagout;
    gpuErrchk( cudaMalloc((void**)&flagout, simparams->nTimes * sizeof(int)) );

    int *idx_Az, *idx_El;
    gpuErrchk( cudaMalloc((void**)&idx_Az, simparams->nTimes * sizeof(int)) );
    gpuErrchk( cudaMalloc((void**)&idx_El, simparams->nTimes * sizeof(int)) );

    // Allocate PWV screen now, delete CUDA allocation after first kernel call
    float *dPWV_screen;
    
    int nPWV_screen = atmosphere->nx * atmosphere->ny;
    
    gpuErrchk( cudaMalloc((void**)&dPWV_screen, nPWV_screen * sizeof(float)) );
    gpuErrchk( cudaMemcpy(dPWV_screen, atmosphere->PWV, nPWV_screen * sizeof(float), cudaMemcpyHostToDevice) );
    
    float *PWV_out;
    gpuErrchk( cudaMalloc((void**)&PWV_out, simparams->nTimes * sizeof(float)) );
    
    float pointing_center[2] = {0., 0.};
    float *dpointing_center;
    gpuErrchk( cudaMalloc((void**)&dpointing_center, 2 * sizeof(float)) );
    gpuErrchk( cudaMemcpy(dpointing_center, pointing_center, 2 * sizeof(float), cudaMemcpyHostToDevice) );
    
    curandState *devStates;
    gpuErrchk( cudaMalloc((void **)&devStates, simparams->nTimes * sizeof(curandState)) );
    
    get_chop_pwv_rng<<<gridSize1D, blockSize1D>>>(dpointing_center, dPWV_screen, PWV_out, flagout, azout, elout, idx_Az, idx_El, devStates);

    float freq;    // Frequency, used for initialising background sources.

    // Allocate and copy blackbodies
    float *I_atm = new float[source->nf];
    float *I_gnd = new float[source->nf];
    float *I_tel = new float[source->nf];
    float *I_CMB = new float[source->nf];

    for(int j=0; j<source->nf; j++)
    {
        freq = source->f0 + source->df * j;
        
        I_atm[j] = getPlanck(atmosphere->Tatm, freq); 
        I_gnd[j] = getPlanck(telescope->Tgnd, freq); 
        I_tel[j] = getPlanck(telescope->Ttel, freq);
        I_CMB[j] = getPlanck(2.725, freq);
    }
   
    gpuErrchk( cudaFree(dPWV_screen) );
    float *dI_atm, *dI_gnd, *dI_tel, *dI_CMB;
    gpuErrchk( cudaMalloc((void**)&dI_atm, source->nf * sizeof(float)) );
    gpuErrchk( cudaMalloc((void**)&dI_gnd, source->nf * sizeof(float)) );
    gpuErrchk( cudaMalloc((void**)&dI_tel, source->nf * sizeof(float)) );
    gpuErrchk( cudaMalloc((void**)&dI_CMB, source->nf * sizeof(float)) );

    gpuErrchk( cudaMemcpy(dI_atm, I_atm, source->nf * sizeof(float), cudaMemcpyHostToDevice) );
    gpuErrchk( cudaMemcpy(dI_gnd, I_gnd, source->nf * sizeof(float), cudaMemcpyHostToDevice) );
    gpuErrchk( cudaMemcpy(dI_tel, I_tel, source->nf * sizeof(float), cudaMemcpyHostToDevice) );
    gpuErrchk( cudaMemcpy(dI_CMB, I_CMB, source->nf * sizeof(float), cudaMemcpyHostToDevice) );
    
    // Allocate and copy source array I_nu
    float *dI_nu;
    int nI_nu = source->nAz * source->nEl * source->nf;

    gpuErrchk( cudaMalloc((void**)&dI_nu, nI_nu * sizeof(float)) );
    gpuErrchk( cudaMemcpy(dI_nu, source->I_nu, nI_nu * sizeof(float), cudaMemcpyHostToDevice) );
    
    // Allocate and copy telescope arrays
    float *deta_ap_ON, *deta_ap_OFF;
    gpuErrchk( cudaMalloc((void**)&deta_ap_ON, source->nf * sizeof(float)) );
    gpuErrchk( cudaMalloc((void**)&deta_ap_OFF, source->nf * sizeof(float)) );
    gpuErrchk( cudaMemcpy(deta_ap_ON, telescope->eta_ap_ON, source->nf * sizeof(float), cudaMemcpyHostToDevice) );
    gpuErrchk( cudaMemcpy(deta_ap_OFF, telescope->eta_ap_OFF, source->nf * sizeof(float), cudaMemcpyHostToDevice) );
    
    gpuErrchk( cudaBindTexture((size_t)0, tex_eta_ap_ON, deta_ap_ON, source->nf * sizeof(float)) );
    gpuErrchk( cudaBindTexture((size_t)0, tex_eta_ap_OFF, deta_ap_OFF, source->nf * sizeof(float)) );

    // Allocate and copy atmosphere arrays
    float *deta_atm;
    int neta_atm = atmosphere->nf * atmosphere->nPWV;
    
    gpuErrchk( cudaMalloc((void**)&deta_atm, neta_atm * sizeof(float)) );
    gpuErrchk( cudaMemcpy(deta_atm, atmosphere->eta_atm, neta_atm * sizeof(float), cudaMemcpyHostToDevice) );

    // Allocate and copy instrument arrays
    float *dfilterbank;
    int nfilterbank = source->nf * instrument->nfreqs_filt;
    gpuErrchk( cudaMalloc((void**)&dfilterbank, nfilterbank * sizeof(float)) );
    
    gpuErrchk( cudaMemcpy(dfilterbank, instrument->filterbank, nfilterbank * sizeof(float), cudaMemcpyHostToDevice) );

    gpuErrchk( cudaBindTexture((size_t)0, tex_filterbank, dfilterbank, nfilterbank * sizeof(float)) );
    
    timer.stop();

    output->t_diag[0] = timer.get();
    
    // CALL TO MAIN SIMULATION KERNEL
    timer.start();

    runSimulation<<<gridSize1D, blockSize1D>>>(dI_atm, dI_gnd, dI_tel, dI_CMB,
            sigout, azout, elout, flagout,
            idx_Az, idx_El,
            PWV_out, deta_atm, dI_nu, devStates);
    
    gpuErrchk( cudaDeviceSynchronize() );
    
    timer.stop();
    output->t_diag[1] = timer.get();
    
    timer.start();

    gpuErrchk( cudaMemcpy(output->signal, sigout, (instrument->nfreqs_filt * simparams->nTimes) * sizeof(float), cudaMemcpyDeviceToHost) );

    gpuErrchk( cudaMemcpy(output->Az, azout, simparams->nTimes * sizeof(int), cudaMemcpyDeviceToHost) );
    gpuErrchk( cudaMemcpy(output->El, elout, simparams->nTimes * sizeof(int), cudaMemcpyDeviceToHost) );
    
    gpuErrchk( cudaMemcpy(output->flag, flagout, simparams->nTimes * sizeof(int), cudaMemcpyDeviceToHost) );

    gpuErrchk( cudaDeviceReset() );

    delete[] I_atm;
    delete[] I_gnd;
    delete[] I_tel;
    delete[] I_CMB;
    
    timer.stop();
    output->t_diag[2] = timer.get();
}

